# 并发编程最新2022年面试题，高级面试题及附答案解析


### 全部答案，更新日期：2022年5月18日，直接下载吧！

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://gitee.com/souyunku/DevBooks/blob/master/docs/index.md)



### [1、ZGC收集器中的染色指针有什么用？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题，高级面试题及附答案解析.md#1zgc收集器中的染色指针有什么用)  


染色指针是一种直接将少量额外的信息存储在指针上的技术，可是为什么指针本身也可以存储额外信息呢？在64位系统中，理论可以访问的内存高达16EB（2的64次幂）字节 [3] 。实际上，基于需求（用不到那么多内存）、性能（地址越宽在做地址转换时需要的页表级数越多）和成本（消耗更多晶体管）的考虑，在AMD64架构 [4] 中只支持到52位（4PB）的地址总线和48位（256TB）的虚拟地址空间，所以目前64位的硬件实际能够支持的最大内存只有256TB。此外，操作系统一侧也还会施加自己的约束，64位的Linux则分别支持47位（128TB）的进程虚拟地址空间和46位（64TB）的物理地址空间，64位的Windows系统甚至只支持44位（16TB）的物理地址空间。尽管Linux下64位指针的高18位不能用来寻址，但剩余的46位指针所能支持的64TB内存在今天仍然能够充分满足大型服务器的需要。鉴于此，ZGC的染色指针技术继续盯上了这剩下的46位指针宽度，将其高4位提取出来存储四个标志信息。通过这些标志位，虚拟机可以直接从指针中看到其引用对象的三色标记状态、是否进入了重分配集（即被移动过）、是否只能通过finalize()方法才能被访问到。当然，由于这些标志位进一步压缩了原本就只有46位的地址空间，也直接导致ZGC能够管理的内存不可以超过4TB（2的42次幂） 。


### [2、什么情况下会发生栈溢出？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题，高级面试题及附答案解析.md#2什么情况下会发生栈溢出)  


栈的大小可以通过-Xss参数进行设置，当递归层次太深的时候，就会发生栈溢出。比如循环调用，递归等。



### [3、CopyOnWriteArrayList 的设计思想?](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题，高级面试题及附答案解析.md#3copyonwritearraylist-的设计思想)  


**1、** 读写分离，读和写分开

**2、** 最终一致性

**3、** 使用另外开辟空间的思路，来解决并发冲突


### [4、为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题，高级面试题及附答案解析.md#4为什么-wait,-notify和-notifyall必须在同步方法或者同步块中被调用)  


当一个线程需要调用对象的 wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 notify()方法。同样的，当一个线程需要调用对象的 notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。


### [5、CopyOnWriteArrayList可以用于什么应用场景？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题，高级面试题及附答案解析.md#5copyonwritearraylist可以用于什么应用场景)  


CopyOnWriteArrayList(免锁容器)的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出ConcurrentModificationException。在CopyOnWriteArrayList中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。

**1、** 由于写操作的时候，需要拷贝数组，会消耗内存，如果原数组的内容比较多的情况下，可能导致young gc或者full gc；

**2、** 不能用于实时读的场景，像拷贝数组、新增元素都需要时间，所以调用一个set操作后，读取到数据可能还是旧的,虽然CopyOnWriteArrayList 能做到最终一致性,但是还是没法满足实时性要求；

**CopyOnWriteArrayList透露的思想**

**1、** 读写分离，读和写分开

**2、** 最终一致性

**3、** 使用另外开辟空间的思路，来解决并发冲突


### [6、线程的 sleep()方法和 yield()方法有什么区别？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题，高级面试题及附答案解析.md#6线程的-sleep方法和-yield方法有什么区别)  


**1、** sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；

**2、** 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；

**3、** sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；

**4、** sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议使用yield()方法来控制并发线程的执行。


### [7、safepoint是什么？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题，高级面试题及附答案解析.md#7safepoint是什么)  


STW并不会只发生在内存回收的时候。现在程序员这么卷，碰到几次safepoint的问题几率也是比较大的。

当发生GC时，用户线程必须全部停下来，才可以进行垃圾回收，这个状态我们可以认为JVM是安全的（safe），整个堆的状态是稳定的。

如果在GC前，有线程迟迟进入不了safepoint，那么整个JVM都在等待这个阻塞的线程，造成了整体GC的时间变长。


### [8、什么是IO密集](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题，高级面试题及附答案解析.md#8什么是io密集)  


IO密集型，即该任务需要大量的IO，即大量的阻塞。在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力浪费在等待。所以在IO密集型任务中使用多线程可以大大的加速程序运行，即时在单核CPU上，这种加速主要就是利用了被浪费掉的阻塞时间。

#
### [9、线程和进程区别](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题，高级面试题及附答案解析.md#9线程和进程区别)  


什么是线程和进程?

**进程**

一个在内存中运行的应用程序。 每个正在系统上运行的程序都是一个进程

**线程**

进程中的一个执行任务（控制单元）， 它负责在程序里独立执行。

一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据

**进程与线程的区别**

**1、** 根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位

**2、** 资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。

**3、** 包含关系：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。

**4、** 内存分配：同一进程的线程共享本进程的地址空间和资源，而进程与进程之间的地址空间和资源是相互独立的

**5、** 影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃有可能导致整个进程都死掉。所以多进程要比多线程健壮。

**6、** 执行过程：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行


### [10、CAS 的会产生什么问题？](https://gitee.com/souyunku/DevBooks/blob/master/docs/并发编程/并发编程最新2021年面试题，高级面试题及附答案解析.md#10cas-的会产生什么问题)  


**ABA 问题：**

比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。从 Java1.5 开始 JDK 的 atomic包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。

**循环时间长开销大：**

对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。

**只能保证一个共享变量的原子操作：**

当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。


### 11、一个线程运行时发生异常会怎样？
### 12、什么是自旋
### 13、什么是上下文切换?
### 14、对象在哪块内存分配？
### 15、什么是FutureTask?使用ExecutorService启动任务。
### 16、方法区
### 17、本地方法栈
### 18、SynchronizedMap和ConcurrentHashMap有什么区别？
### 19、用过ConcurrentHashMap，讲一下他和HashTable的不同之处？
### 20、能够找到 Reference Chain 的对象，就一定会存活么？
### 21、synchronized和ReentrantLock的区别
### 22、JVM 数据运行区，哪些会造成 OOM 的情况？
### 23、类的实例化顺序
### 24、什么是线程池？有哪几种创建方式？
### 25、Java 中怎么获取一份线程 dump 文件？你如何在 Java 中获取线程堆栈？
### 26、Java中垃圾回收有什么目的？什么时候进行垃圾回收？
### 27、synchronized、volatile、CAS 比较
### 28、程序计数器
### 29、对象分配内存是否线程安全？
### 30、谈谈双亲委派模型
### 31、为什么使用Executor框架比使用应用创建和管理线程好？
### 32、GC 是什么? 为什么要有 GC





## [全部答案，更新日期：2022年5月18日，直接下载吧！](https://gitee.com/souyunku/DevBooks/blob/master/docs/daan.md)

### 下载链接：[全部答案，整理好了](https://gitee.com/souyunku/DevBooks/blob/master/docs/daan.md)




## [新增：高清PDF：172份，7701页，最新整理](https://gitee.com/souyunku/DevBooks/blob/master/docs/daan.md)




