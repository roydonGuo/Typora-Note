# Java面试题大全带答案，持续更新


### 全部答案，更新日期：2022年5月18日，直接下载吧！

### 下载链接：[高清172份，累计 7701 页大厂面试题  PDF](https://gitee.com/souyunku/DevBooks/blob/master/docs/index.md)



### [1、说一下Java对象的创建过程](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java面试题大全带答案，持续更新.md#1说一下java对象的创建过程)  


**1、** 类加载检查：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。2）分配内存：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。选择以上2种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的。

**2、** 在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：CAS+失败重试：CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。TLAB：为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配

**3、** 初始化零值：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

**4、** 设置对象头：初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。这些信息存放在对象头中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

**5、** 执行 init 方法：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，  方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行  方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。


### [2、Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java面试题大全带答案，持续更新.md#2java-中-linkedhashmap-和-priorityqueue-的区别是什么)  


PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，但是 LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。


### [3、ThreadPoolExecutor饱和策略有哪些？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java面试题大全带答案，持续更新.md#3threadpoolexecutor饱和策略有哪些)  


`如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任时，ThreadPoolTaskExecutor 定义一些策略:`

**1、** ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException来拒绝新任务的处理。

**2、** ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程运行任务。您不会任务请求。但是这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。

**3、** ThreadPoolExecutor.DiscardPolicy：不处理新任务，直接丢弃掉。

**4、** ThreadPoolExecutor.DiscardOldestPolicy： 此策略将丢弃最早的未处理的任务请求。


### [4、可达性分析](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java面试题大全带答案，持续更新.md#4可达性分析)  


为了解决引用计数法的循环引用问题， Java 使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。要注意的是，不可达对象不等价于可回收对象， 不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。


### [5、成员变量与局部变量的区别有那些？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java面试题大全带答案，持续更新.md#5成员变量与局部变量的区别有那些)  


**1、** 从语法形式上，看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；成员变量和局部变量都能被final所修饰；

**2、** 从变量在内存中的存储方式来看，成员变量是对象的一部分，而对象存在于堆内存，局部变量存在于栈内存

**3、** 从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。

**4、** 成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（一种情况例外被final修饰但没有被static修饰的成员变量必须显示地赋值）；而局部变量则不会自动赋值。


### [6、HashMap 的长度为什么是2的幂次方](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java面试题大全带答案，持续更新.md#6hashmap-的长度为什么是2的幂次方)  


为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。

**这个算法应该如何设计呢？**

我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&)操作（也就是说 hash%length==hash&(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。

**那为什么是两次扰动呢？**

这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；


### [7、谈谈JVM中，对类加载器的认识](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java面试题大全带答案，持续更新.md#7谈谈jvm中对类加载器的认识)  


类加载器是JVM的组成部分之一。将字节码文件加载进JVM。

**类加载分为四部分：**

**1、** BootStrapClassLoader，即跟类加载器，加载java运行时所需的类，如String，Integer等存在${java_home}/jre/lib/rt.jar包类的所有类。

**2、** ExtensionClassLoader,扩展类加载器，加载一些扩展类，即${java_home}/jre/lib/ext/*.jar包

**3、** AppClassLoader，系统加载类，加载自定义的类，级classpath下的所有类

**4、** ClassLoader 抽象类加载器：用户自定义的类加载器，用户定义的类加载器都要继承次ClassLoader

**5、** Jvm默认采用的是双亲委派类加载机制，即先加载父类在加载子类，对上面四个类加载器采用自顶向下加载


### [8、你对线程优先级的理解是什么？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java面试题大全带答案，持续更新.md#8你对线程优先级的理解是什么)  


**1、** 每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。

**2、** java的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。


### [9、构造器（constructor）是否可被重写（override）？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java面试题大全带答案，持续更新.md#9构造器constructor是否可被重写override)  




构造器不能被继承，因此不能被重写，但可以被重载。


### [10、JVM 年轻代到年老代的晋升过程的判断条件是什么呢？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Java/Java面试题大全带答案，持续更新.md#10jvm-年轻代到年老代的晋升过程的判断条件是什么呢)  


**1、** 部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代。

**2、** 如果对象的大小大于Eden的二分之一会直接分配在old，如果old也分配不下，会做一次majorGC，如果小于eden的一半但是没有足够的空间，就进行minorgc也就是新生代GC。

**3、** minor gc后，survivor仍然放不下，则放到老年代

**4、** 动态年龄判断 ，大于等于某个年龄的对象超过了survivor空间一半 ，大于等于某个年龄的对象直接进入老年代


### 11、什么是字节码？采用字节码的最大好处是什么？什么Java是虚拟机？
### 12、策略模式的优点和缺点
### 13、Spring中如何使用注解来配置Bean？有哪些相关的注解？
### 14、什么是乐观锁和悲观锁
### 15、多线程的劣势：
### 16、Java的数据结构有那些？
### 17、你都用过G1垃圾回收器的哪几个重要参数？
### 18、类与对象的关系?
### 19、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？
### 20、==与equlas有什么区别？
### 21、集合框架底层数据结构
### 22、当打开其他程序的网页时，使用的target属性是哪个？
### 23、java中有几种方法可以实现一个线程？
### 24、多线程的常用方法
### 25、可以直接调用Thread类的run ()方法么？
### 26、如果父类只有有参构造方法，那么子类必须要重写父类的构造方法吗？
### 27、守护线程和用户线程有什么区别呢？
### 28、你在项目中哪些地方用到了XML？
### 29、什么时候使用组合模式？
### 30、是否可以继承String类？
### 31、栈
### 32、阐述JDBC操作数据库的步骤。
### 33、谈谈对 OOM 的认识
### 34、说一下垃圾分代收集的过程
### 35、什么是UML？
### 36、怎么查看服务器默认的垃圾回收器是哪一个？
### 37、简述Java的对象结构
### 38、什么是CAS
### 39、请解释StackOverflowError和OutOfMemeryError的区别？
### 40、Java中如何实现多线程





## [全部答案，更新日期：2022年5月18日，直接下载吧！](https://gitee.com/souyunku/DevBooks/blob/master/docs/daan.md)

### 下载链接：[全部答案，整理好了](https://gitee.com/souyunku/DevBooks/blob/master/docs/daan.md)




## [新增：高清PDF：172份，7701页，最新整理](https://gitee.com/souyunku/DevBooks/blob/master/docs/daan.md)




