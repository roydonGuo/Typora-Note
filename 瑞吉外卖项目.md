# d1

https://pan.baidu.com/s/1_oQyDrGXDZzdWxrBS2eNBQ  提取码：j4tn

## 新建数据库

![image-20220926173527348](C:\Users\31330\Pictures\Typora\image-20220926173527348.png)







创建maven项目

![image-20220926174238372](C:\Users\31330\Pictures\Typora\image-20220926174238372.png)

## pml.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.4.5</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.roydon</groupId>
    <artifactId>reggie</artifactId>
    <version>1.0-SNAPSHOT</version>

    <properties>
        <maven.compiler.source>8</maven.compiler.source>
        <maven.compiler.target>8</maven.compiler.target>
    </properties>
    <dependencies>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <scope>compile</scope>
        </dependency>

        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.4.2</version>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.20</version>
        </dependency>

        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
            <version>1.2.76</version>
        </dependency>

        <dependency>
            <groupId>commons-lang</groupId>
            <artifactId>commons-lang</artifactId>
            <version>2.6</version>
        </dependency>

        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>druid-spring-boot-starter</artifactId>
            <version>1.1.23</version>
        </dependency>

    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>2.4.5</version>
            </plugin>
        </plugins>
    </build>
</project>
```

## application.yml

```yml
server:
  port: 8080
spring:
  application:
    #应用的名称，可选
    name: reggie
  datasource:
    druid:
      driver-class-name: com.mysql.cj.jdbc.Driver
      url: jdbc:mysql://localhost:3306/db_reggie?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8&zeroDateTimeBehavior=convertToNull&useSSL=false&allowPublicKeyRetrieval=true
      username: root
      password: qwer1234
mybatis-plus:
  configuration:
    #在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射
    map-underscore-to-camel-case: true
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  global-config:
    db-config:
      id-type: ASSIGN_ID
```

## 启动类

ReggieApplication

```java
package com.roydon.reggie;

import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * Created by Intellij IDEA
 * Author: yi cheng
 * Date: 2022/9/26
 * Time: 17:50
 **/
@Slf4j
@SpringBootApplication
public class ReggieApplication {
    public static void main(String[] args) {
        SpringApplication.run(ReggieApplication.class,args);
        log.info("项目启动成功");
    }
}
```

## 引入静态资源

![image-20220926175924309](C:\Users\31330\Pictures\Typora\image-20220926175924309.png)

## 配置静态资源映射

默认静态资源在template下，所以需要配置映射

新建包 config 新建配置规则 WebMvcConfig

```java
package com.roydon.reggie.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;

/**
 * Created by Intellij IDEA
 * Author: yi cheng
 * Date: 2022/9/26
 * Time: 18:00
 **/
@Slf4j
@Configuration
public class WebMvcConfig extends WebMvcConfigurationSupport {
    /**
     * 设置静态资源映射
     * @param registry
     */
    @Override
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {

        log.info("开始进行静态资源映射...");
        registry.addResourceHandler("/backend/**").addResourceLocations("classpath:/backend/");
        registry.addResourceHandler("/front/**").addResourceLocations("classpath:/front/");

    }
}
```

启动项目访问 [http://localhost:8080/backend/page/login/login.html](http://localhost:8080/backend/page/login/login.html) 登录页面

common文件夹下新建包装类 R.java 。与前端约定数据传输类型

```java
package com.roydon.reggie.common;

import lombok.Data;
import java.util.HashMap;
import java.util.Map;

/**
 * 通用返回结果，服务端响应的数据最终都会封装成此对象
 * @param <T>
 */
@Data
public class R<T> {

    private Integer code; //编码：1成功，0和其它数字为失败

    private String msg; //错误信息

    private T data; //数据

    private Map map = new HashMap(); //动态数据

    public static <T> R<T> success(T object) {
        R<T> r = new R<T>();
        r.data = object;
        r.code = 1;
        return r;
    }

    public static <T> R<T> error(String msg) {
        R r = new R();
        r.msg = msg;
        r.code = 0;
        return r;
    }

    public R<T> add(String key, Object value) {
        this.map.put(key, value);
        return this;
    }

}
```

员工层

![image-20220926203044878](C:\Users\31330\Pictures\Typora\image-20220926203044878.png)

controller - EmployeeController：

```java
package com.roydon.reggie.controller;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.roydon.reggie.common.R;
import com.roydon.reggie.entity.Employee;
import com.roydon.reggie.service.EmployeeService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.util.DigestUtils;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;

@Slf4j
@RestController
@RequestMapping("/employee")
public class EmployeeController {

    @Resource
    private EmployeeService employeeService;

    /**
     * 员工登录
     * @param request
     * @param employee
     * @return
     */
    @PostMapping("/login")
    public R<Employee> login(HttpServletRequest request, @RequestBody Employee employee){

        //1、将页面提交的密码password进行md5加密处理
        String password = employee.getPassword();
        password = DigestUtils.md5DigestAsHex(password.getBytes());

        //2、根据页面提交的用户名username查询数据库
        LambdaQueryWrapper<Employee> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(Employee::getUsername,employee.getUsername());
        Employee emp = employeeService.getOne(queryWrapper);

        //3、如果没有查询到则返回登录失败结果
        if(emp == null){
            return R.error("登录失败");
        }

        //4、密码比对，如果不一致则返回登录失败结果
        if(!emp.getPassword().equals(password)){
            return R.error("登录失败");
        }

        //5、查看员工状态，如果为已禁用状态，则返回员工已禁用结果
        if(emp.getStatus() == 0){
            return R.error("账号已禁用");
        }

        //6、登录成功，将员工id存入Session并返回登录成功结果
        request.getSession().setAttribute("employee",emp.getId());
        return R.success(emp);
    }

    /**
     * 员工退出
     * @param request
     * @return
     */
    @PostMapping("/logout")
    public R<String> logout(HttpServletRequest request){
        //清理Session中保存的当前登录员工的id
        request.getSession().removeAttribute("employee");
        return R.success("退出成功");
    }
}
```

实体类：

```java
package com.roydon.reggie.entity;

import com.baomidou.mybatisplus.annotation.FieldFill;
import com.baomidou.mybatisplus.annotation.TableField;
import lombok.Data;
import java.io.Serializable;
import java.time.LocalDateTime;

/**
 * 员工实体
 */
@Data
public class Employee implements Serializable {

    private static final long serialVersionUID = 1L;

    private Long id;

    private String username;

    private String name;

    private String password;

    private String phone;

    private String sex;

    private String idNumber;//身份证号码

    private Integer status;

    private LocalDateTime createTime;

    private LocalDateTime updateTime;

    @TableField(fill = FieldFill.INSERT)
    private Long createUser;

    @TableField(fill = FieldFill.INSERT_UPDATE)
    private Long updateUser;

}
```

mapper：

```java
package com.roydon.reggie.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.roydon.reggie.entity.Employee;
import org.apache.ibatis.annotations.Mapper;

@Mapper
public interface EmployeeMapper extends BaseMapper<Employee>{
}
```

service：

```java
package com.roydon.reggie.service;


import com.baomidou.mybatisplus.extension.service.IService;
import com.roydon.reggie.entity.Employee;

public interface EmployeeService extends IService<Employee> {

}
```

impl：

```java
package com.roydon.reggie.service.impl;


import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.roydon.reggie.entity.Employee;
import com.roydon.reggie.mapper.EmployeeMapper;
import com.roydon.reggie.service.EmployeeService;
import org.springframework.stereotype.Service;

@Service
public class EmployeeServiceImpl extends ServiceImpl<EmployeeMapper, Employee> implements EmployeeService {

}
```





# d2

## 完善登录功能

只有登录后才能进入主页面，可以使用**过滤器**或者**拦截器**判断用户是否登录。

本项目使用过滤器 filter 实现：

```java
package com.roydon.reggie.filter;

import lombok.extern.slf4j.Slf4j;
import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * Created by Intellij IDEA
 * Author: yi cheng
 * Date: 2022/9/26
 * Time: 21:05
 * 检查用户是否登录过滤器
 **/
@Slf4j
@WebFilter(filterName = "loginCheckFilter", urlPatterns = "/*")
public class LoginCheckFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;
        log.info("拦截到了请求：{}",request.getRequestURI());
        filterChain.doFilter(request,response);
    }
}
```

若要让filter生效需要在启动类添加注解：@ServletComponentScan

```java
package com.roydon.reggie;

import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.web.servlet.ServletComponentScan;

/**
 * Created by Intellij IDEA
 * Author: yi cheng
 * Date: 2022/9/26
 * Time: 17:50
 **/
@Slf4j
@SpringBootApplication
@ServletComponentScan
public class ReggieApplication {
    public static void main(String[] args) {
        SpringApplication.run(ReggieApplication.class,args);
        log.info("<=====项目启动成功=====>");
    }
}
```

调试发现确实拦截到了请求。

![image-20220926212015523](C:\Users\31330\Pictures\Typora\image-20220926212015523.png)

接着就是filter判断是否登录实现逻辑：

1、获取本次请求的URI

2、判断本次请求是否需要处理

3、如果不需要处理，则直接放行

4、判断登录状态，如果已登录，则直接放行

5、如果未登录则返回未登录结果，通过输出流方式向客户端页面响应数据

完善过滤器：

```java
import com.alibaba.fastjson.JSON;
import com.roydon.reggie.common.R;
import lombok.extern.slf4j.Slf4j;
import org.springframework.util.AntPathMatcher;
import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * Created by Intellij IDEA
 * Author: yi cheng
 * Date: 2022/9/26
 * Time: 21:05
 * 检查用户是否登录过滤器
 **/
@Slf4j
@WebFilter(filterName = "loginCheckFilter", urlPatterns = "/*")
public class LoginCheckFilter implements Filter {

    //路径匹配器，支持通配符
    public static final AntPathMatcher PATH_MATCHER = new AntPathMatcher();

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;

        // 1、获取本次请求的URI
        String requestURI = request.getRequestURI();

        log.info("拦截到请求：{}",requestURI);

        // 2、判断本次请求是否需要处理
        //定义不需要处理的请求路径
        String[] urls = new String[]{
                "/employee/login",
                "/employee/logout",
                "/backend/**",
                "/front/**"
        };
        //2、判断本次请求是否需要处理
        boolean check = check(urls, requestURI);

        //3、如果不需要处理，则直接放行
        if (check) {
            log.info("本次请求{}不需要处理", requestURI);
            filterChain.doFilter(request, response);
            return;
        }

        //4、判断登录状态，如果已登录，则直接放行
        if (request.getSession().getAttribute("employee") != null) {
            log.info("用户已登录，用户id为：{}", request.getSession().getAttribute("employee"));
            filterChain.doFilter(request, response);
            return;
        }

        log.info("用户未登录");
        //5、如果未登录则返回未登录结果，通过输出流方式向客户端页面响应数据，转为json：JSON.toJSONString
        response.getWriter().write(JSON.toJSONString(R.error("NOTLOGIN")));

        /*log.info("拦截到了请求：{}", request.getRequestURI());
        filterChain.doFilter(request, response);*/
    }

    /**
     * 路径匹配，检查本次请求是否需要放行
     *
     * @param urls
     * @param requestURI
     * @return
     */
    public boolean check(String[] urls, String requestURI) {
        for (String url : urls) {
            boolean match = PATH_MATCHER.match(url, requestURI);
            if (match) {
                return true;
            }
        }
        return false;
    }
}
```



## 新增员工接口

```java
/**
 * 新增员工
 * @param employee
 * @param request
 * @return
 */
@PostMapping
public R<String> save(HttpServletRequest request,
                        @RequestBody Employee employee){

    log.info("新增员工。员工信息：{}",employee.toString());

    // 为新增员工设置默认密码 123456 ，并进行加密处理
    employee.setPassword(DigestUtils.md5DigestAsHex("123456".getBytes()));

    employee.setCreateTime(LocalDateTime.now());
    employee.setUpdateTime(LocalDateTime.now());

    // 获取当前登录用户的id
    Long empId = (Long) request.getSession().getAttribute("employee");
    employee.setCreateUser(empId);
    employee.setUpdateUser(empId);

    employeeService.save(employee);

    return R.success("新增员工成功");
}
```

自定义全局异常处理：

场景：如，在新增用户场景下，如果账号已经存在，就会保存失败，所以需要自定义捕获异常

当然一种方法是直接在controller的新增员工接口里try，catch，但是随着业务增多，try会写很多遍。所以推荐使用全局异常捕获。

![image-20220927191354675](C:\Users\31330\Pictures\Typora\image-20220927191354675.png)

当用户名重复会报错

```shell
Duplicate entry 'roydon' for key 'employee.idx_username'
```

![image-20220927192227814](C:\Users\31330\Pictures\Typora\image-20220927192227814.png)

```java
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import java.sql.SQLIntegrityConstraintViolationException;

/**
 * Created by Intellij IDEA
 * Author: yi cheng
 * Date: 2022/9/27
 * Time: 19:07
 **/
@Slf4j
@ControllerAdvice(annotations = {
        RestController.class, Controller.class
})
@ResponseBody
public class GlobalExceptionHandler {

    /**
     * 全局异常处理
     * @param ex
     * @return
     */
    @ExceptionHandler(SQLIntegrityConstraintViolationException.class)
    public R<String> exceptionHandler(SQLIntegrityConstraintViolationException ex){
        log.error(ex.getMessage());

        if (ex.getMessage().contains("Duplicate entry")) {
            return R.error(ex.getMessage().split(" ")[2]+"也存在");
        }

        return R.error("未知错误");
    }

}
```



## 主页员工信息分页显示

前端请求URL：``http://localhost:8080/employee/page?page=1&pageSize=10``

根据name姓名查询：``http://localhost:8080/employee/page?page=1&pageSize=10&name=``

```java
@GetMapping("/page")
public R getPage(@RequestParam Integer page,
                 @RequestParam Integer pageSize,
                 @RequestParam(defaultValue = "") String name) {
    QueryWrapper<Employee> queryWrapper = new QueryWrapper<>();
    queryWrapper.like(Strings.isNotEmpty(name), "name", name);// 这里传入属性名最好用接口
    // 也可以给queryWrapper配置排序规则
    return R.success(employeeService.page(new Page<>(page, pageSize), queryWrapper));
}
```

## 启用/禁用员工账号

（只有管理员可以操作，前端v-if已经判断过）

请求接口：``http://localhost:8080/employee``

可以直接添加一个全局可用的employee更新接口，后面编辑同样调用此接口。

正常写完业务会发现前端报错了，前端传入URL的id的值由于超出精度导致精度不准确，所以后台接口调用失败，例如：

数据库用户的id为：1574786887262941186，为long型数据。但是传入前端后精度不对，所以导致前端在此提交到后端的id为：1574786887262941200。

此时需要全局对象转换器，把传给前端的数字型数据统一转换成string字符串类型。

在common文件夹下新建 JacksonObjectMapper

```java
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.module.SimpleModule;
import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;
import java.math.BigInteger;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import static com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;

/**
 * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象
 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]
 * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]
 */
public class JacksonObjectMapper extends ObjectMapper {

    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
    public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";

    public JacksonObjectMapper() {
        super();
        //收到未知属性时不报异常
        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

        //反序列化时，属性不存在的兼容处理
        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);

        SimpleModule simpleModule = new SimpleModule()
                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))

                .addSerializer(BigInteger.class, ToStringSerializer.instance)
                .addSerializer(Long.class, ToStringSerializer.instance)
                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

        //注册功能模块 例如，可以添加自定义序列化器和反序列化器
        this.registerModule(simpleModule);
    }
}
```

扩展mvc框架的消息转换器，配置到WebMvcConfig

```java
import com.roydon.reggie.common.JacksonObjectMapper;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;

import java.util.List;

/**
 * Created by Intellij IDEA
 * Author: yi cheng
 * Date: 2022/9/26
 * Time: 18:00
 **/
@Slf4j
@Configuration
public class WebMvcConfig extends WebMvcConfigurationSupport {
    /**
     * 设置静态资源映射
     * @param registry
     */
    @Override
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {

        log.info("开始进行静态资源映射...");
        registry.addResourceHandler("/backend/**").addResourceLocations("classpath:/backend/");
        registry.addResourceHandler("/front/**").addResourceLocations("classpath:/front/");

    }

    /**
     * 扩展mvc框架的消息转换器
     * @param converters
     */
    @Override
    protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {

        // 创建消息转换对象
        MappingJackson2HttpMessageConverter messageConverter = new MappingJackson2HttpMessageConverter();
        // 设置对象转换器，底层使用Jackson将Java对象转为json
        messageConverter.setObjectMapper(new JacksonObjectMapper());
        // 将上面的消息转换器对象追加到mvc框架的转换器集合中
        converters.add(0,messageConverter);

    }
}
```



## 编辑员工信息

为编辑员工信息提供一个根据id查询一条数据的接口，让前端数据回显

```java
/**
 * 根据id查询一条数据
 *
 * @param id
 * @return
 */
@GetMapping("/{id}")
public R<Employee> getById(@PathVariable Long id) {

    Employee employee = employeeService.getById(id);
    if (employee != null) {
        return R.success(employee);
    }
    return R.error("查无此人");

}
```



## 公共字段自动填充

例如更新时间，创建时间等需要单独set的，可以统一处理

mp已经为我们提供了@TableFiled注解

```java
@TableField(fill = FieldFill.INSERT)
// 和
@TableField(fill = FieldFill.INSERT_UPDATE)
```

由于，这些线程是出于同一线程，所以用ThreadLocal封装工具类，用户保存和获取当前登录用户id

```java
package com.roydon.reggie.common;

/**
 * 基于ThreadLocal封装工具类，用户保存和获取当前登录用户id
 */
public class BaseContext {
    private static ThreadLocal<Long> threadLocal = new ThreadLocal<>();

    /**
     * 设置值
     *
     * @param id
     */
    public static void setCurrentId(Long id) {
        threadLocal.set(id);
    }

    /**
     * 获取值
     *
     * @return
     */
    public static Long getCurrentId() {
        return threadLocal.get();
    }
}
```


自定义元数据对象处理器

```java
package com.roydon.reggie.common;

import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
import lombok.extern.slf4j.Slf4j;
import org.apache.ibatis.reflection.MetaObject;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;

/**
 * 自定义元数据对象处理器
 */
@Component
@Slf4j
public class MyMetaObjecthandler implements MetaObjectHandler {
    /**
     * 插入操作，自动填充
     * @param metaObject
     */
    @Override
    public void insertFill(MetaObject metaObject) {
        log.info("公共字段自动填充[insert]...");
        log.info(metaObject.toString());
        metaObject.setValue("createTime", LocalDateTime.now());
        metaObject.setValue("updateTime",LocalDateTime.now());
        metaObject.setValue("createUser", BaseContext.getCurrentId());
        metaObject.setValue("updateUser",BaseContext.getCurrentId());
    }

    /**
     * 更新操作，自动填充
     * @param metaObject
     */
    @Override
    public void updateFill(MetaObject metaObject) {
        log.info("公共字段自动填充[update]...");
        log.info(metaObject.toString());

        long id = Thread.currentThread().getId();
        log.info("线程id为：{}",id);

        metaObject.setValue("updateTime",LocalDateTime.now());
        metaObject.setValue("updateUser",BaseContext.getCurrentId());
    }
}
```

# d3



## 菜品分类接口

```java
package com.roydon.reggie.controller;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.roydon.reggie.common.R;
import com.roydon.reggie.entity.Category;
import com.roydon.reggie.service.CategoryService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

/**
 * 分类管理
 */
@RestController
@RequestMapping("/category")
@Slf4j
public class CategoryController {
    @Autowired
    private CategoryService categoryService;

    /**
     * 新增分类
     *
     * @param category
     * @return
     */
    @PostMapping
    public R<String> save(@RequestBody Category category) {
        log.info("category:{}", category);
        categoryService.save(category);
        return R.success("新增分类成功");
    }

    /**
     * 分页查询
     *
     * @param page
     * @param pageSize
     * @return
     */
    @GetMapping("/page")
    public R<Page> page(int page, int pageSize) {
        //分页构造器
        Page<Category> pageInfo = new Page<>(page, pageSize);
        //条件构造器
        LambdaQueryWrapper<Category> queryWrapper = new LambdaQueryWrapper<>();
        //添加排序条件，根据sort进行排序
        queryWrapper.orderByAsc(Category::getSort);

        //分页查询
        categoryService.page(pageInfo, queryWrapper);
        return R.success(pageInfo);
    }

    /**
     * 根据id删除分类
     *
     * @param id
     * @return
     */
    @DeleteMapping
    public R<String> delete(Long id) {
        log.info("删除分类，id为：{}", id);

        categoryService.removeById(id);
//        categoryService.remove(id);

        return R.success("分类信息删除成功");
    }

    /**
     * 根据id修改分类信息
     *
     * @param category
     * @return
     */
    @PutMapping
    public R<String> update(@RequestBody Category category) {
        log.info("修改分类信息：{}", category);

        categoryService.updateById(category);

        return R.success("修改分类信息成功");
    }
}
```



## 删除菜品



删除菜品分类时关联查询有没有菜品在此分类下，有的话则不能删除此菜品分类

所以impl里自定义一个删除方法用来判断是否有关联关系

```java
package com.roydon.reggie.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.roydon.reggie.common.CustomException;
import com.roydon.reggie.entity.Category;
import com.roydon.reggie.entity.Dish;
import com.roydon.reggie.entity.Setmeal;
import com.roydon.reggie.mapper.CategoryMapper;
import com.roydon.reggie.service.CategoryService;
import com.roydon.reggie.service.DishService;
import com.roydon.reggie.service.SetmealService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class CategoryServiceImpl extends ServiceImpl<CategoryMapper, Category> implements CategoryService {

    @Autowired
    private DishService dishService;

    @Autowired
    private SetmealService setmealService;

    /**
     * 根据id删除分类，删除之前需要进行判断
     * @param id
     */
    @Override
    public void remove(Long id) {
        LambdaQueryWrapper<Dish> dishLambdaQueryWrapper = new LambdaQueryWrapper<>();
        //添加查询条件，根据分类id进行查询
        dishLambdaQueryWrapper.eq(Dish::getCategoryId,id);
        int count1 = (int) dishService.count(dishLambdaQueryWrapper);

        //查询当前分类是否关联了菜品，如果已经关联，抛出一个业务异常
        if(count1 > 0){
            //已经关联菜品，抛出一个业务异常
            throw new CustomException("当前分类下关联了菜品，不能删除");
        }

        //查询当前分类是否关联了套餐，如果已经关联，抛出一个业务异常
        LambdaQueryWrapper<Setmeal> setmealLambdaQueryWrapper = new LambdaQueryWrapper<>();
        //添加查询条件，根据分类id进行查询
        setmealLambdaQueryWrapper.eq(Setmeal::getCategoryId,id);
        int count2 = (int) setmealService.count();
        if(count2 > 0){
            //已经关联套餐，抛出一个业务异常
            throw new CustomException("当前分类下关联了套餐，不能删除");
        }

        //正常删除分类
        super.removeById(id);
    }
}
```



# d4



## 文件上传，下载



spring-web提供了一个MultipartFile类可以方便的接收文件

### 文件上传

前端upload部分使用element

上传的请求地址为``http://localhost:8080/common/upload``

```vue
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>文件上传</title>
  <!-- 引入样式 -->
  <link rel="stylesheet" href="../../plugins/element-ui/index.css" />
  <link rel="stylesheet" href="../../styles/common.css" />
  <link rel="stylesheet" href="../../styles/page.css" />
</head>
<body>
   <div class="addBrand-container" id="food-add-app">
    <div class="container">
        <el-upload class="avatar-uploader"
                action="/common/upload"
                :show-file-list="false"
                :on-success="handleAvatarSuccess"
                :before-upload="beforeUpload"
                ref="upload">
            <img v-if="imageUrl" :src="imageUrl" class="avatar" alt=""/>
            <i v-else class="el-icon-plus avatar-uploader-icon"></i>
        </el-upload>
    </div>
  </div>
    <!-- 开发环境版本，包含了有帮助的命令行警告 -->
    <script src="../../plugins/vue/vue.js"></script>
    <!-- 引入组件库 -->
    <script src="../../plugins/element-ui/index.js"></script>
    <!-- 引入axios -->
    <script src="../../plugins/axios/axios.min.js"></script>
    <script src="../../js/index.js"></script>
    <script>
      new Vue({
        el: '#food-add-app',
        data() {
          return {
            imageUrl: ''
          }
        },
        methods: {
          handleAvatarSuccess (response, file, fileList) {
              this.imageUrl = `/common/download?name=${response.data}`
          },
          beforeUpload (file) {
            if(file){
              const suffix = file.name.split('.')[1]
              const size = file.size / 1024 / 1024 < 2
              if(['png','jpeg','jpg'].indexOf(suffix) < 0){
                this.$message.error('上传图片只支持 png、jpeg、jpg 格式！')
                this.$refs.upload.clearFiles()
                return false
              }
              if(!size){
                this.$message.error('上传文件大小不能超过 2MB!')
                return false
              }
              return file
            }
          }
        }
      })
    </script>
</body>
</html>
```

文件上传接口层

```java
package com.roydon.reggie.controller;

import cn.hutool.core.io.FileUtil;
import cn.hutool.core.util.IdUtil;
import cn.hutool.core.util.StrUtil;
import com.roydon.reggie.common.R;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;

/**
 * Created by Intellij IDEA
 * Author: yi cheng
 * Date: 2022/9/29
 * Time: 16:54
 **/
@Slf4j
@RestController
@RequestMapping("/common")
public class CommonController {

    @Value("${files.upload.path}")
    private String uploadPath;

    /**
     * 文件上传
     *
     * @param file
     * @return
     */
    @PostMapping("/upload")
    public R<String> upload(@RequestPart("file") MultipartFile file) {
        // 前端upload组件用的ele，会自动生成一个input，它的name为file所以此方法参数名也需为file
        // file是一个临时文件，暂时存在c盘temp相关tomcat文件夹下，需要后续转存
        log.info("文件上传...");
//        try {
//            // 转存到指定目录，不推荐写死，一般在yml配置文件里配置
//            file.transferTo(new File("D:\\hello.jpg"));
//        } catch (IOException e) {
//            e.printStackTrace();
//        }
        /*转存文件配置好路径，可优化为*/
//        try {
//            // 转存到配置目录，文件名写死了，所以此方法也不推荐
//            file.transferTo(new File(uploadPath+"hello.jpg"));
//        } catch (IOException e) {
//            e.printStackTrace();
//        }
        //String originalFilename = file.getOriginalFilename();//获取原始文件名（上传的文件名）
        /*使用原始文件名的方式转存*/
//        try {
//            // 转存到配置目录，但文件名会重名发生覆盖，所以不推荐
//            String originalFilename = file.getOriginalFilename();
//            file.transferTo(new File(uploadPath + originalFilename));
//        } catch (IOException e) {
//            e.printStackTrace();
//        }
        /*使用uuid生成随机文件名，避免重名覆盖问题*/
        String originalFilename = file.getOriginalFilename();//获取上传文件名，可以用字符串截取lastIndexOf，推荐hutool
        String fileType = FileUtil.extName(originalFilename);// jpg\png\jpeg...(不带点.)
        long fileSize = file.getSize();// 获取文件大小
        // 生成随机uuid作为文件名
        String uuid = IdUtil.fastSimpleUUID();// uuid也可以使用 UUID.randomUUID().toString();
        // 加上文件类型的完整文件名
        String fileUUIDName = uuid + StrUtil.DOT + fileType;// StrUtil.DOT 就是一个点（.）
        log.info("文件存储路径：{}，存储文件名：{}，文件大小约：{}", uploadPath, fileUUIDName, fileSize/1024+"K");
        // 如果配置文件指定的目录不存在则创建
        File dir = new File(uploadPath);
        if (!dir.exists()) {
            // 不存在就创建
            dir.mkdirs();
        }
        try {
            file.transferTo(new File(uploadPath + fileUUIDName));
        } catch (IOException e) {
            e.printStackTrace();
        }

        return R.success(fileUUIDName);
    }

}
```

### 文件下载

请求网址: ``http://localhost:8080/common/download?name=undefined``。方式GET

就是上传图片回显到浏览器。简单思路如下：

> 1、上传图片后，拿到通过uuid生成的文件名 return R.success(fileUUIDName);



```java
package com.roydon.reggie.controller;

import cn.hutool.core.io.FileUtil;
import cn.hutool.core.util.IdUtil;
import cn.hutool.core.util.StrUtil;
import com.roydon.reggie.common.R;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

/**
 * Created by Intellij IDEA
 * Author: yi cheng
 * Date: 2022/9/29
 * Time: 16:54
 **/
@Slf4j
@RestController
@RequestMapping("/common")
public class CommonController {

    @Value("${files.upload.path}")
    private String uploadPath;

    /**
     * 文件上传
     *
     * @param file
     * @return
     */
    @PostMapping("/upload")
    public R<String> upload(@RequestPart("file") MultipartFile file) {
        // 前端upload组件用的ele，会自动生成一个input，它的name为file所以此方法参数名也需为file
        // file是一个临时文件，暂时存在c盘temp相关tomcat文件夹下，需要后续转存
        log.info("文件上传...");
//        try {
//            // 转存到指定目录，不推荐写死，一般在yml配置文件里配置
//            file.transferTo(new File("D:\\hello.jpg"));
//        } catch (IOException e) {
//            e.printStackTrace();
//        }
        /*转存文件配置好路径，可优化为*/
//        try {
//            // 转存到配置目录，文件名写死了，所以此方法也不推荐
//            file.transferTo(new File(uploadPath+"hello.jpg"));
//        } catch (IOException e) {
//            e.printStackTrace();
//        }
        //String originalFilename = file.getOriginalFilename();//获取原始文件名（上传的文件名）
        /*使用原始文件名的方式转存*/
//        try {
//            // 转存到配置目录，但文件名会重名发生覆盖，所以不推荐
//            String originalFilename = file.getOriginalFilename();
//            file.transferTo(new File(uploadPath + originalFilename));
//        } catch (IOException e) {
//            e.printStackTrace();
//        }
        /*使用uuid生成随机文件名，避免重名覆盖问题*/
        String originalFilename = file.getOriginalFilename();//获取上传文件名，可以用字符串截取lastIndexOf，推荐hutool
        String fileType = FileUtil.extName(originalFilename);// jpg\png\jpeg...(不带点.)
        long fileSize = file.getSize();// 获取文件大小
        // 生成随机uuid作为文件名
        String uuid = IdUtil.fastSimpleUUID();// uuid也可以使用 UUID.randomUUID().toString();
        // 加上文件类型的完整文件名
        String fileUUIDName = uuid + StrUtil.DOT + fileType;// StrUtil.DOT 就是一个点（.）
        log.info("文件存储路径：{}，存储文件名：{}，文件大小约：{}", uploadPath, fileUUIDName, fileSize / 1024 + "K");
        // 如果配置文件指定的目录不存在则创建
        File dir = new File(uploadPath);
        if (!dir.exists()) {
            // 不存在就创建
            dir.mkdirs();
        }
        try {
            file.transferTo(new File(uploadPath + fileUUIDName));
        } catch (IOException e) {
            e.printStackTrace();
        }

        return R.success(fileUUIDName);
    }

    /**
     * 文件下载
     *
     * @param fileUUIDName
     * @param response     相应浏览器
     */
    @GetMapping("/download")
    public void download(@RequestParam("name") String fileUUIDName, HttpServletResponse response) {

        try {
            // 输入流读取文件
            FileInputStream fileInputStream = new FileInputStream(new File(uploadPath + fileUUIDName));
            // 输出流写入文件到浏览器
            ServletOutputStream outputStream = response.getOutputStream();

            // 代表响应文件为图片
            response.setContentType("image/jpeg");

            //开始读取
//            response.addHeader("Content-Disposition", "attachment;filename=" + URLEncoder.encode(fileUUIDName, "UTF-8"));
//            response.setContentType("application/octet-stream");
//            response.getOutputStream().write(FileUtil.readBytes(new File(fileUUIDName)));//一步搞定
            int len = 0;
            byte[] bytes = new byte[1024];

            while ((len = fileInputStream.read(bytes)) != -1) {
                outputStream.write(bytes, 0, len);
                outputStream.flush();// 刷新
            }
            // 关闭流
            outputStream.close();
            fileInputStream.close();
        } catch (Exception e) {
            e.printStackTrace();
        }

    }
}
```



## 菜品管理

对应数据库dish

数据传输对象dishDto

```java
package com.roydon.reggie.entity.dto;

import com.roydon.reggie.entity.Dish;
import com.roydon.reggie.entity.DishFlavor;
import lombok.Data;

import java.util.ArrayList;
import java.util.List;

/**
 * 数据传输对象
 */
@Data
public class DishDto extends Dish {

    private List<DishFlavor> flavors = new ArrayList<>();

    private String categoryName;

    private Integer copies;
}
```





**

**

**



# d5

开发关于移动端的需求。

## 手机验证码登录

### 短信发送

使用ali云提供的包

aliyun官网注册账号，购买短信服务

p81

```java
package com.roydon.reggie.controller;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.roydon.reggie.common.R;
import com.roydon.reggie.entity.User;
import com.roydon.reggie.service.UserService;
import com.roydon.reggie.utils.ValidateCodeUtils;
import lombok.extern.slf4j.Slf4j;
import org.apache.logging.log4j.util.Strings;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.annotation.Resource;
import javax.servlet.http.HttpSession;
import java.util.Map;

@RestController
@RequestMapping("/user")
@Slf4j
public class UserController {

    @Resource
    private UserService userService;

    /**
     * 发送手机短信验证码
     *
     * @param user
     * @return
     */
    @PostMapping("/sendMsg")
    public R<String> sendMsg(@RequestBody User user, HttpSession session) {
        //获取手机号
        String phone = user.getPhone();

        if (Strings.isNotEmpty(phone)) {
            //生成随机的4位验证码
            String code = ValidateCodeUtils.generateValidateCode(4).toString();
            log.info("code={}", code);

            //调用阿里云提供的短信服务API完成发送短信
            //SMSUtils.sendMessage("瑞吉外卖","",phone,code);

            //需要将生成的验证码保存到Session
            session.setAttribute(phone, code);

            return R.success("手机验证码短信发送成功");
        }

        return R.error("短信发送失败");
    }

    /**
     * 移动端用户登录
     *
     * @param map
     * @param session
     * @return
     */
    @PostMapping("/login")
    public R<User> login(@RequestBody Map map, HttpSession session) {
        log.info(map.toString());

        //获取手机号
        String phone = map.get("phone").toString();

        //获取验证码
        String code = map.get("code").toString();

        //从Session中获取保存的验证码
        Object codeInSession = session.getAttribute(phone);

        //进行验证码的比对（页面提交的验证码和Session中保存的验证码比对）
        if (codeInSession != null && codeInSession.equals(code)) {
            //如果能够比对成功，说明登录成功

            LambdaQueryWrapper<User> queryWrapper = new LambdaQueryWrapper<>();
            queryWrapper.eq(User::getPhone, phone);

            User user = userService.getOne(queryWrapper);
            if (user == null) {
                //判断当前手机号对应的用户是否为新用户，如果是新用户就自动完成注册
                user = new User();
                user.setPhone(phone);
                user.setStatus(1);
                userService.save(user);
            }
            session.setAttribute("user", user.getId());
            return R.success(user);
        }
        return R.error("登录失败");
    }
}
```



验证码放在session中存在一个问题就是，session默认存活时间为30分钟，对于验证码来说只要五分钟就够了，所以验证码需要优化放在redis中。

```xml
<!--redis-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```



```yml
spring:
  redis:
	host: 192.168.52.128
	port: 6379
	password: qwer1234
	database: 1
```









# 性能优化





## redis缓存短信验证码







## Spring Cache

始终注解大大提高效率









## 数据库主从复制







## 读写分离











菜品展示 P95







